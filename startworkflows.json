package com.modak.bots.basebot;

import com.google.common.collect.ArrayListMultimap;
import com.google.common.collect.Multimap;
import com.modak.utils.*;
import com.modak.utils.encryption.MessageEncryptionUtil;
import com.modak.utils.encryption.RSAUtils;
import com.zaxxer.hikari.HikariDataSource;
import org.apache.commons.dbutils.QueryRunner;
import org.apache.kafka.clients.consumer.ConsumerRecord;
import org.apache.kafka.clients.consumer.ConsumerRecords;
import org.apache.kafka.clients.consumer.KafkaConsumer;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.stringtemplate.v4.ST;
import org.stringtemplate.v4.STGroup;
import org.stringtemplate.v4.STGroupFile;

import java.io.File;
import java.nio.charset.StandardCharsets;
import java.sql.Connection;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;

public class WorkFlowTests {​
    private static final Logger logger = LogManager.getLogger(WorkFlowTests.class.getName());
    String resources_path = null;
    HashMap<String, Object> metadataMap = null;
    HikariDataSource hikariDataSource = null;


    public WorkFlowTests(String resources_path) {​
        this.resources_path = resources_path;
        this.metadataMap = metadataMap;
        this.hikariDataSource = hikariDataSource;
    }​


    public void initScriptsForWorkflows() throws Exception {​
        STGroup stGroup = new STGroupFile(resources_path + File.separator + "templates/database_init_sqls.stg", '$', '$');
        ST workflowInitSqls = stGroup.getInstanceOf("workflow_init_sql");
        workflowInitSqls.add("metadata", metadataMap);
        System.out.println(workflowInitSqls.render());
        Connection connection = hikariDataSource.getConnection();
        new QueryRunner().update(connection, workflowInitSqls.render());
        connection.close();

    }​


    public void testBotWorkflow() throws Exception {​
        STGroup stGroup = new STGroupFile(resources_path + File.separator + "templates/bots_testing/1.0/bot_test_messages.stg", '$', '$');
        ST workflowStartupJson = stGroup.getInstanceOf("start_workflow_config");
        List<HashMap<String, Object>> workorkflowsForTestingList = (List<HashMap<String, Object>>) JSONUtils.jsonToMap(workflowStartupJson.render()).get("workflow_test_cases_list");
        for (HashMap<String, Object> workflowForTestingMap : workorkflowsForTestingList) {​
            ArrayList<String> workflowTopicsList = (ArrayList<String>) workflowForTestingMap.get("workflow_topics");
            new Thread(new Runnable() {​
                @Override
                public void run() {​
                    try {​
                        logger.info("Started Testing workflow : {​}​ ", workflowForTestingMap.get("workflow_name"));
                        STGroup stGroup1 = new STGroupFile(resources_path + File.separator + "templates\\bot_test_messages.stg", '$', '$');
                        HashMap<String, Object> cosumerConfigMap = JSONUtils.jsonToMap(stGroup1.getInstanceOf("consumer_props").render());
                        KafkaConsumer validationConsumer = KafkaUtils.getKafkaConsumer(cosumerConfigMap);
                        KafkaUtils.subscribeToTopics(validationConsumer, workflowTopicsList);

                        List<HashMap<String, Object>> testCaseList = (List<HashMap<String, Object>>) workflowForTestingMap.get("test_cases");
                        for (HashMap<String, Object> testCaseMap : testCaseList) {​
                            logger.info("Testing {​}​ with test case description  :{​}​", workflowForTestingMap.get("workflow_name"), workflowForTestingMap.get("test_case_description"));
                            try {​
                                HashMap<String, Object> workflowStartMessageDetailsMap = (HashMap<String, Object>) testCaseMap.get("start_message_template_details");
                                String templateGroup = workflowStartMessageDetailsMap.get("template_group").toString();
                                String templateName = workflowStartMessageDetailsMap.get("template_name").toString();
                                STGroup stGroup = new STGroupFile(templateGroup, '$', '$');
                                Long process_id = System.currentTimeMillis();
                                String messageToBePublished = stGroup.getInstanceOf(templateName).add("process_id", process_id).render();
                                String producerConfigJsonString = stGroup.getInstanceOf("producer_props").add("bot_metadata", metadataMap).render();
                                String topic = MapUtils.getString(JSONUtils.jsonToMap(messageToBePublished), "bot_metadata.message_topic");
                                MessagePublisherUtil messagePublisherUtil = new MessagePublisherUtil(resources_path);
                                Map<String, Object> producer_props = JSONUtils.jsonToMap(producerConfigJsonString);
                                messagePublisherUtil.initialize(producer_props);
                                new Thread(new Runnable() {​
                                    @Override
                                    public void run() {​
                                        monitorAndValidateWorkflow(workflowForTestingMap, validationConsumer, ArrayListMultimap.create());
                                    }​
                                }​).start();
                                Thread.sleep(10000);
                                messagePublisherUtil.publishMesssage(topic, messageToBePublished);
                                logger.info("Message {​}​ published on topic {​}​", messageToBePublished, topic);
                            }​ catch (Exception e) {​
                                e.printStackTrace();
                            }​
                        }​
                    }​ catch (Exception e) {​
                        e.printStackTrace();
                    }​
                }​
            }​).start();
        }​
    }​

    private void monitorAndValidateWorkflow(HashMap workflowForTestingMap, KafkaConsumer validationConsumer, Multimap<String, String> actualMap) {​
        try {​
            logger.info("Montioring for the foll:"+workflowForTestingMap,actualMap);
            while (true) {​
                try {​
                    Thread.sleep(200);
                }​ catch (InterruptedException e) {​
                    logger.error("Exception occurred while trying to sleep");
                    Thread.currentThread().interrupt();
                }​
                ConsumerRecords<String, byte[]> messageRecords = validationConsumer.poll(100);
                for (ConsumerRecord<String, byte[]> messageRecord : messageRecords) {​
                    byte[] messageBytes = messageRecord.value();
                    validationConsumer.commitSync();
                    try {​
                        byte[] decryptedBytes = MessageEncryptionUtil.decryptAndUncompressByteArray(messageBytes, RSAUtils.getPrivateKey(resources_path + File.separator + "config\\keys\\privateKey"));
                        String message = null;
                        if (decryptedBytes != null) {​
                            message = new String(decryptedBytes, StandardCharsets.UTF_8);
                        }​
                        logger.info(
                                "Message received topic = {​}​ offset = {​}​ partition = {​}​ decryptedMessage = {​}​ ", messageRecord.topic(), messageRecord.offset(), messageRecord.partition(),
                                MiscUtils.formatString(message, true));
                        validateMessageConsumed(workflowForTestingMap, message, actualMap);
                    }​ catch (Exception e) {​
                        e.printStackTrace();
                    }​
                }​
            }​
        }​ catch (Exception e) {​
            e.printStackTrace();
        }​
    }​

    private void validateMessageConsumed(HashMap<String, Object> workflowForTestingMap, String message, Multimap<String, String> actualResultMap) {​
        try {​
            HashMap<String, Object> completionCriteriaMap = (HashMap<String, Object>) workflowForTestingMap.get("workflow_completion_criteria");
            String completionTopic = completionCriteriaMap.get("completion_topic").toString();
            String completionProcessContext = completionCriteriaMap.get("process_context").toString();

            HashMap<String, Object> botMessageMap = JSONUtils.jsonToMap(message);
            String botTopic = MapUtils.getString(botMessageMap, "bot_metadata.message_topic");
            String processContext = MapUtils.getString(botMessageMap, "bot_metadata.message_context");
            ArrayListMultimap successCriteriaMap = (ArrayListMultimap) completionCriteriaMap.get("workflow_success_criteria");
            HashMap<String, Object> errorCriteriaMap = (HashMap<String, Object>) completionCriteriaMap.get("workflow_error_criteria");


            if (botTopic.equals(completionTopic) && processContext.equals(completionProcessContext)) {​
                logger.info("Flow completed successfully without any errors");
                boolean status = validateWorkflowCompletion(successCriteriaMap, actualResultMap);
                if (status) {​
                    doValidationTestsForCompletedWorkflow();
                }​ else {​
                }​
            }​ else if (errorCriteriaMap.containsKey(botTopic) && errorCriteriaMap.get(botTopic).equals(processContext)) {​
                logger.info("FLow errored out ");
            }​ else {​
                actualResultMap.put(botTopic, processContext);
            }​
        }​ catch (Exception e) {​
            e.printStackTrace();
        }​
    }​

    private void doValidationTestsForCompletedWorkflow() {​

    }​

    private boolean validateWorkflowCompletion(ArrayListMultimap successCriteriaMap, Multimap<String, String> actualResultMap) {​
        logger.info("Ecpected Result :" + JSONUtils.object2JsonString(successCriteriaMap));
        logger.info("Actual Result Map :" + JSONUtils.object2JsonString(actualResultMap));
        return successCriteriaMap.equals(actualResultMap);
    }​
}​